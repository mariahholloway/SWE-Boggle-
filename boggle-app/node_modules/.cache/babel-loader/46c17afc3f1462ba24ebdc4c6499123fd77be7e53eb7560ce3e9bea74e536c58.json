{"ast":null,"code":"/**\r\n * Given a Boggle board and a dictionary, returns a list of available words in\r\n * the dictionary present inside of the Boggle board.\r\n * @param {string[][]} grid - The Boggle game board.\r\n * @param {string[]} dictionary - The list of available words.\r\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\r\n */\n\nexports.findAllSolutions = function (grid, dictionary) {\n  let solutions = [];\n\n  // 1. Check inputs params are valid \n  // 1a. Check for any empty input\n  if (grid == null || dictionary == null) return solutions;\n\n  // 1b. Check if NXN\n  let N = grid.length;\n  for (let i = 0; i < N; i++) {\n    if (grid[i].length != N) {\n      return solutions;\n    }\n  }\n\n  // Convert input data into the same case\n  lowerCaseConvert(grid, dictionary);\n\n  // Check if Grid is valid\n  if (!isValidGrid(grid)) {\n    //        console.log('Test' + grid);\n    return solutions;\n  }\n\n  // Set up data structures (visited, solutions, dictionary, Trie, hash, list, set)\n\n  let solutionSet = new Set();\n  let hash = createHashMap(dictionary);\n\n  // Iterate over the NxN grid\n\n  for (let y = 0; y < N; y++) {\n    for (let x = 0; x < N; x++) {\n      let word = \"\";\n      let visited = new Array(N).fill(false).map(() => new Array(N).fill(false));\n      findWords(word, y, x, grid, visited, hash, solutionSet);\n    }\n  }\n  solutions = Array.from(solutionSet);\n  return solutions;\n};\nfindWords = function (word, y, x, grid, visited, hash, solutionSet) {\n  let adjMatrix = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\n  if (y < 0 || x < 0 || y >= grid.length || x >= grid.length || visited[y][x] == true) return;\n  word += grid[y][x];\n\n  //     console.log(\"Current Word = \" + word + \"\\nGrid[\" + y + \"][\" + x + \"] = \" + grid[x][y]);\n\n  if (isPrefix(word, hash)) {\n    visited[y][x] = true;\n    if (isWord(word, hash)) {\n      if (word.length >= 3) solutionSet.add(word);\n    }\n    for (let i = 0; i < 8; i++) {\n      findWords(word, y + adjMatrix[i][0], x + adjMatrix[i][1], grid, visited, hash, solutionSet);\n    }\n  }\n  visited[y][x] = false;\n};\nisPrefix = function (word, hash) {\n  return hash[word] != undefined;\n};\nisWord = function (word, hash) {\n  return hash[word] == 1;\n};\ncreateHashMap = function (dictionary) {\n  var dict = {};\n  for (let i = 0; i < dictionary.length; i++) {\n    dict[dictionary[i]] = 1;\n    let wordlength = dictionary[i].length;\n    var str = dictionary[i];\n    for (let j = wordlength; wordlength > 1; wordlength--) {\n      str = str.substr(0, wordlength - 1);\n      if (str in dict) {\n        if (str == 1) {\n          dict[str] = 1;\n        }\n      } else {\n        dict[str] = 0;\n      }\n    }\n  }\n  return dict;\n};\nlowerCaseConvert = function (grid, dict) {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      grid[i][j] = grid[i][j].toLowerCase();\n    }\n  }\n  for (let i = 0; i < dict.length; i++) {\n    dict[i] = dict[i].toLowerCase();\n  }\n};\nisValidGrid = function (grid) {\n  regex = /(st|qu)|[a-prt-z]/;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (!grid[i][j].match(regex)) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nvar grid = [['t', 'w', 'y', 'r'], ['e', 'n', 'p', 'h'], ['g', 'z', 'qu', 'r'], ['o', 'n', 't', 'a']];\nvar dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat', 'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp', 'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar'];","map":{"version":3,"names":["exports","findAllSolutions","grid","dictionary","solutions","N","length","i","lowerCaseConvert","isValidGrid","solutionSet","Set","hash","createHashMap","y","x","word","visited","Array","fill","map","findWords","from","adjMatrix","isPrefix","isWord","add","undefined","dict","wordlength","str","j","substr","toLowerCase","regex","match"],"sources":["C:/Users/myahh/OneDrive/Documents/boggle/boggle-app/src/boggle_solver.js"],"sourcesContent":["/**\r\n * Given a Boggle board and a dictionary, returns a list of available words in\r\n * the dictionary present inside of the Boggle board.\r\n * @param {string[][]} grid - The Boggle game board.\r\n * @param {string[]} dictionary - The list of available words.\r\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\r\n */\r\n\r\n\r\n exports.findAllSolutions = function(grid, dictionary) {\r\n  let solutions = [];\r\n\r\n  // 1. Check inputs params are valid \r\n  // 1a. Check for any empty input\r\n  if(grid == null || dictionary == null)\r\n    return solutions;\r\n   \r\n  // 1b. Check if NXN\r\n  let N = grid.length;\r\n  for(let i = 0; i <N; i++){\r\n    if(grid[i].length != N){\r\n      \r\n      return solutions;\r\n    }\r\n  }\r\n   \r\n   // Convert input data into the same case\r\n  lowerCaseConvert(grid, dictionary);\r\n   \r\n   \r\n   // Check if Grid is valid\r\n   if(!isValidGrid(grid)){\r\n//        console.log('Test' + grid);\r\n     return solutions;\r\n   }\r\n   \r\n   \r\n   \r\n   // Set up data structures (visited, solutions, dictionary, Trie, hash, list, set)\r\n  \r\n  let solutionSet = new Set();\r\n  let hash = createHashMap(dictionary);\r\n   \r\n   // Iterate over the NxN grid\r\n   \r\n  for(let y = 0; y < N; y++){\r\n    for(let x = 0; x < N; x++){\r\n      let word = \"\";\r\n      \r\n      let visited = new Array(N).fill(false).map(() => new Array(N).fill(false));\r\n      \r\n      findWords(word, y, x, grid, visited, hash, solutionSet);\r\n    }\r\n  }\r\n  \r\n  solutions = Array.from(solutionSet);\r\n  return solutions;\r\n}\r\n\r\n  findWords = function(word, y, x, grid, visited, hash, solutionSet){\r\n    \r\n    let adjMatrix = [[-1, -1],\r\n                    [-1, 0],\r\n                    [-1, 1],\r\n                    [0, 1],\r\n                    [1, 1],\r\n                    [1, 0],\r\n                    [1, -1],\r\n                    [0, -1]];\r\n    \r\n    if (y < 0 || x < 0 || y >= grid.length || x >= grid.length || visited[y][x] == true)\r\n      return;\r\n    \r\n    word += grid[y][x];\r\n    \r\n//     console.log(\"Current Word = \" + word + \"\\nGrid[\" + y + \"][\" + x + \"] = \" + grid[x][y]);\r\n    \r\n    if(isPrefix(word, hash)) {\r\n      visited[y][x] = true;\r\n      \r\n      if(isWord(word, hash)) {\r\n        if(word.length >= 3)\r\n          solutionSet.add(word);\r\n      }\r\n      \r\n     for(let i = 0; i < 8; i++){\r\n       findWords(word, y + adjMatrix[i][0], x + adjMatrix[i][1], grid, visited, hash, solutionSet)\r\n        }\r\n    }\r\n    \r\n    visited[y][x] = false;\r\n  }\r\n  \r\n  isPrefix = function(word, hash) {\r\n    return hash[word] != undefined;\r\n\r\n  }\r\n\r\n  isWord = function(word, hash) {\r\n    return hash[word] == 1;\r\n  }\r\n\r\n  createHashMap = function(dictionary){\r\n    var dict = {};\r\n    for(let i = 0; i < dictionary.length; i++){\r\n      dict[dictionary[i]] = 1;\r\n      let wordlength = dictionary[i].length;\r\n      var str = dictionary[i];\r\n      for(let j = wordlength; wordlength > 1; wordlength--){\r\n        str = str.substr(0,wordlength-1);\r\n        if(str in dict){\r\n          if(str == 1){\r\n            dict[str] = 1;\r\n          }\r\n        }\r\n        else{\r\n          dict[str] = 0;\r\n        }\r\n      }\r\n    }\r\n    return dict;\r\n  }\r\n  \r\n  lowerCaseConvert = function(grid, dict){\r\n    for(let i = 0; i < grid.length; i++){\r\n      for(let j = 0; j < grid[i].length; j++){\r\n        grid[i][j] = grid[i][j].toLowerCase();\r\n      }\r\n    }\r\n    \r\n    for(let i = 0; i < dict.length; i++){\r\n      dict[i] = dict[i].toLowerCase();\r\n    }\r\n  }\r\n\r\n  isValidGrid = function(grid){\r\n    regex = /(st|qu)|[a-prt-z]/;\r\n    for(let i = 0; i < grid.length; i++){\r\n      for(let j = 0; j < grid[i].length; j++){\r\n        if(!grid[i][j].match(regex)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\nvar grid = [['t', 'w', 'y', 'r'],\r\n              ['e', 'n', 'p', 'h'],\r\n              ['g', 'z', 'qu', 'r'],\r\n              ['o', 'n', 't', 'a']];\r\nvar dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat',\r\n                    'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp',\r\n                    'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar'];\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}